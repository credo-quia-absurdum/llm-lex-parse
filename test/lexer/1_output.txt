KEY	struct	1
ID	_point	1
OP	{
KEY	float	1
ID	x	1
OP	,
ID	y	1
OP	,
ID	z	1
OP	;
KEY	int	1
ID	color	1
OP	;
OP	}
ID	point	1
OP	[
INT	20
OP	]
OP	;
KEY	struct	2
ID	_line	1
OP	{
KEY	struct	3
ID	_point	2
OP	*
ID	p	1
OP	[
INT	2
OP	]
OP	;
KEY	int	2
ID	color	2
OP	;
OP	}
ID	line	1
OP	[
INT	20
OP	]
OP	;
KEY	struct	4
ID	_model	1
OP	{
KEY	struct	5
ID	_line	2
OP	*
ID	l	1
OP	;
KEY	int	3
ID	cardinal	1
OP	;
KEY	char	1
OP	*
ID	name	1
OP	;
OP	}
OP	;
KEY	float	2
ID	pi	1
OP	;
KEY	float	3
ID	find_large_length_line	1
OP	(
KEY	struct	6
ID	_model	2
OP	*
ID	m	1
OP	)
OP	;
ID	main	1
OP	(
OP	)
OP	{
KEY	struct	7
ID	_model	3
ID	object1	1
OP	;
KEY	int	4
ID	i	1
OP	;
ID	pi	2
OP	=
F	3.14
OP	;
KEY	for	1
OP	(
ID	i	2
OP	=
INT	0
OP	;
ID	i	3
OP	<
INT	20
OP	;
OP	++
ID	i	4
OP	)
OP	{
ID	point	2
OP	[
ID	i	5
OP	]
OP	.
ID	x	2
OP	=
ID	i	6
OP	*
ID	i	7
OP	+
F	14.4
OP	*
ID	i	8
OP	+
INT	4
OP	;
ID	point	3
OP	[
ID	i	9
OP	]
OP	.
ID	y	2
OP	=
OP	-
OP	(
ID	i	10
OP	*
ID	i	11
OP	-
INT	24
OP	*
ID	i	12
OP	+
INT	8
OP	)
OP	;
ID	point	4
OP	[
ID	i	13
OP	]
OP	.
ID	z	2
OP	=
INT	10
OP	*
ID	i	14
OP	+
INT	5
OP	;
OP	}
ID	i	15
OP	=
INT	19
OP	;
KEY	while	1
OP	(
ID	i	16
OP	>=
INT	0
OP	)
OP	{
ID	line	2
OP	[
ID	i	17
OP	]
OP	.
ID	p	2
OP	[
INT	0
OP	]
OP	=
OP	&
ID	point	5
OP	[
ID	i	18
OP	]
OP	;
KEY	if	1
OP	(
ID	i	19
OP	==
INT	19
OP	)
ID	line	3
OP	[
ID	i	20
OP	]
OP	.
ID	p	3
OP	[
INT	1
OP	]
OP	=
OP	&
ID	point	6
OP	[
INT	0
OP	]
OP	;
KEY	else	1
ID	line	4
OP	[
ID	i	21
OP	]
OP	.
ID	p	4
OP	[
INT	1
OP	]
OP	=
OP	&
ID	point	7
OP	[
ID	i	22
OP	+
INT	1
OP	]
OP	;
OP	--
ID	i	23
OP	;
OP	}
ID	object1	2
OP	.
ID	cardinal	2
OP	=
INT	20
OP	;
ID	object1	3
OP	.
ID	l	2
OP	=
ID	line	5
OP	;
ID	object1	4
OP	.
ID	name	2
OP	=
ID	polygon1	1
OP	;
OP	{
KEY	float	4
ID	max	1
OP	;
ID	max	2
OP	=
ID	find_large_length_line	2
OP	(
OP	&
ID	object1	5
OP	)
OP	;
KEY	return	1
ID	max	3
OP	;
OP	}
OP	}
KEY	float	5
ID	find_large_legnth_line	1
OP	(
OP	)
OP	{
KEY	int	5
ID	count	1
OP	;
KEY	float	6
ID	max_length	1
OP	;
KEY	if	2
OP	(
OP	*
OP	(
ID	m	2
OP	->
ID	name	3
OP	)
OP	==
ID	d	1
OP	)
KEY	return	2
INT	14
OP	..
INT	2
OP	;
ID	count	2
OP	=
ID	m	3
OP	->
ID	cardinal	3
OP	;
ID	max_length	2
OP	=
OP	-
INT	1
OP	;
KEY	while	2
OP	(
ID	count	3
OP	>=
INT	0
OP	)
OP	{
KEY	float	7
ID	length	1
OP	,
ID	dx	1
OP	,
ID	dy	1
OP	,
ID	dz	1
OP	;
ID	dx	2
OP	=
ID	m	4
OP	->
ID	l	3
OP	[
ID	count	4
OP	]
OP	.
ID	p	5
OP	[
INT	0
OP	]
OP	->
ID	x	3
OP	-
ID	m	5
OP	->
ID	l	4
OP	[
ID	count	5
OP	]
OP	.
ID	p	6
OP	[
INT	1
OP	]
OP	->
ID	x	4
OP	;
ID	dy	2
OP	=
ID	m	6
OP	->
ID	l	5
OP	[
ID	count	6
OP	]
OP	.
ID	p	7
OP	[
INT	0
OP	]
OP	->
ID	y	3
OP	-
ID	m	7
OP	->
ID	l	6
OP	[
ID	count	7
OP	]
OP	.
ID	p	8
OP	[
INT	1
OP	]
OP	->
ID	y	4
OP	;
ID	dz	2
OP	=
ID	m	8
OP	->
ID	l	7
OP	[
ID	count	8
OP	]
OP	.
ID	p	9
OP	[
INT	0
OP	]
OP	->
ID	z	3
OP	-
ID	m	9
OP	->
ID	l	8
OP	[
ID	count	9
OP	]
OP	.
ID	p	10
OP	[
INT	1
OP	]
OP	->
ID	z	4
OP	;
ID	length	2
OP	=
ID	dx	3
OP	*
ID	dx	4
OP	+
ID	dy	3
OP	*
ID	dy	4
OP	+
ID	dz	3
OP	*
ID	dz	4
OP	;
KEY	if	3
OP	(
ID	max_length	3
OP	<
ID	length	3
OP	)
ID	max_length	4
OP	=
ID	length	4
OP	;
OP	--
ID	count	10
OP	;
OP	}
KEY	return	3
ID	max_length	5
OP	;
OP	}
OP	(
OP	)
OP	,
OP	[
OP	]
OP	,
OP	{
OP	}
OP	,
OP	->
OP	,
OP	.
OP	,
OP	,
OP	,
OP	!
OP	,
OP	++
OP	,
OP	--
OP	,
OP	*
OP	,
OP	/
OP	,
OP	%
OP	,
OP	+
OP	,
OP	-
OP	,
OP	<
OP	,
OP	<=
OP	,
OP	>
OP	,
OP	>=
OP	,
OP	==
OP	,
OP	!=
OP	,
OP	&
OP	,
OP	&&
OP	,
OP	||
OP	,
OP	;
OP	,
OP	=
KEY	break	1
OP	,
KEY	char	2
OP	,
KEY	continue	1
OP	,
KEY	else	2
OP	,
KEY	float	8
OP	,
KEY	for	2
OP	,
KEY	if	4
OP	,
KEY	int	6
OP	,
KEY	return	4
OP	,
KEY	struct	8
OP	,
KEY	while	3
OP	,
KEY	NULL	1
